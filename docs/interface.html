<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2022-05-31 
 | Rendered using Apache Maven Fluido Skin 1.5
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Jose Zalacain" />
    <meta name="Date-Creation-yyyymmdd" content="20190331" />
    <meta name="Date-Revision-yyyymmdd" content="20220531" />
    <meta http-equiv="Content-Language" content="en" />
    <title>prolobjectlink-jpi-jpl-yap &#x2013; Title</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.5.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.5.min.js"></script>

                      </head>
        <body class="topBarEnabled">
          
    
    
            
    
        
    <a href="https://github.com/prolobjectlink-jpi-jpl-yap">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"
        alt="Fork me on GitHub">
    </a>
  
                
                    
                

    <div id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
                <div class="container-fluid">
        <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
                
                                <ul class="nav">
                          <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Overview <b class="caret"></b></a>
        <ul class="dropdown-menu">
        
                      <li>      <a href="whatis.html"  title="What Is">What Is</a>
</li>
                  
                      <li>      <a href="started.html"  title="Getting Started">Getting Started</a>
</li>
                  
                      <li>      <a href="prolog.html"  title="Prolog Programming">Prolog Programming</a>
</li>
                  
                      <li>      <a href="interface.html"  title="Bidirectional Interface">Bidirectional Interface</a>
</li>
                  
                      <li>      <a href="tools.html"  title="Development Tools">Development Tools</a>
</li>
                  
                      <li>      <a href="contribution.html"  title="Contribution">Contribution</a>
</li>
                  
                      <li>      <a href="related.html"  title="Related Works">Related Works</a>
</li>
                  
                      <li>      <a href="blob/master/docs/prolobjectlink-jpi-jpl-yap.pdf"  title="User Guide">User Guide</a>
</li>
                  
                      <li>      <a href="download.html"  title="Download">Download</a>
</li>
                  
                      <li>      <a href="faq.html"  title="FAQ">FAQ</a>
</li>
                          </ul>
      </li>
                <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Project Documentation <b class="caret"></b></a>
        <ul class="dropdown-menu">
        
                      <li class="dropdown-submenu">
                                      <a href="project-info.html"  title="Project Information">Project Information</a>
              <ul class="dropdown-menu">
                                  <li>      <a href="project-summary.html"  title="Project Summary">Project Summary</a>
</li>
                                  <li>      <a href="index.html"  title="About">About</a>
</li>
                                  <li>      <a href="dependencies.html"  title="Dependencies">Dependencies</a>
</li>
                                  <li>      <a href="team-list.html"  title="Project Team">Project Team</a>
</li>
                                  <li>      <a href="license.html"  title="Project License">Project License</a>
</li>
                                  <li>      <a href="source-repository.html"  title="Source Repository">Source Repository</a>
</li>
                                  <li>      <a href="integration.html"  title="Continuous Integration">Continuous Integration</a>
</li>
                                  <li>      <a href="mail-lists.html"  title="Mailing Lists">Mailing Lists</a>
</li>
                                  <li>      <a href="issue-tracking.html"  title="Issue Tracking">Issue Tracking</a>
</li>
                                  <li>      <a href="dependency-info.html"  title="Dependency Information">Dependency Information</a>
</li>
                                  <li>      <a href="distribution-management.html"  title="Distribution Management">Distribution Management</a>
</li>
                                  <li>      <a href="plugin-management.html"  title="Plugin Management">Plugin Management</a>
</li>
                                  <li>      <a href="plugins.html"  title="Project Plugins">Project Plugins</a>
</li>
                              </ul>
            </li>
                  
                      <li class="dropdown-submenu">
                                      <a href="project-reports.html"  title="Project Reports">Project Reports</a>
              <ul class="dropdown-menu">
                                  <li>      <a href="apidocs/index.html"  title="Javadoc">Javadoc</a>
</li>
                                  <li>      <a href="testapidocs/index.html"  title="Test Javadoc">Test Javadoc</a>
</li>
                                  <li>      <a href="checkstyle.html"  title="Checkstyle">Checkstyle</a>
</li>
                                  <li>      <a href="xref-test/index.html"  title="Test Source Xref">Test Source Xref</a>
</li>
                                  <li>      <a href="xref/index.html"  title="Source Xref">Source Xref</a>
</li>
                                  <li>      <a href="findbugs.html"  title="FindBugs">FindBugs</a>
</li>
                                  <li>      <a href="jdepend-report.html"  title="JDepend">JDepend</a>
</li>
                                  <li>      <a href="pmd.html"  title="PMD Report">PMD Report</a>
</li>
                                  <li>      <a href="cpd.html"  title="CPD Report">CPD Report</a>
</li>
                                  <li>      <a href="jacoco/index.html"  title="JaCoCo Test">JaCoCo Test</a>
</li>
                                  <li>      <a href="changes-report.html"  title="Changes">Changes</a>
</li>
                                  <li>      <a href="taglist.html"  title="Tag List">Tag List</a>
</li>
                                  <li>      <a href="javancss.html"  title="JavaNCSS Report">JavaNCSS Report</a>
</li>
                                  <li>      <a href="clirr-report.html"  title="Clirr">Clirr</a>
</li>
                                  <li>      <a href="surefire-report.html"  title="Surefire Report">Surefire Report</a>
</li>
                                  <li>      <a href="dependency-updates-report.html"  title="Dependency Updates Report">Dependency Updates Report</a>
</li>
                                  <li>      <a href="plugin-updates-report.html"  title="Plugin Updates Report">Plugin Updates Report</a>
</li>
                                  <li>      <a href="property-updates-report.html"  title="Property Updates Report">Property Updates Report</a>
</li>
                              </ul>
            </li>
                          </ul>
      </li>
                  </ul>
          
          
          
                   
                      </div>
          
        </div>
      </div>
    </div>
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>prolobjectlink-jpi-jpl-yap</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
              
                  <li id="publishDate">Last Published: 2022-05-31
                      <span class="divider">|</span>
                   </li>
                  <li id="projectVersion">Version: 1.1-SNAPSHOT
                      </li>
                      
              
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
              
                <ul class="nav nav-list">
                    <li class="nav-header">Overview</li>
                              
      <li>
  
                          <a href="whatis.html" title="What Is">
          <span class="none"></span>
        What Is</a>
            </li>
                
      <li>
  
                          <a href="started.html" title="Getting Started">
          <span class="none"></span>
        Getting Started</a>
            </li>
                
      <li>
  
                          <a href="prolog.html" title="Prolog Programming">
          <span class="none"></span>
        Prolog Programming</a>
            </li>
                
      <li class="active">
  
            <a href="#"><span class="none"></span>Bidirectional Interface</a>
          </li>
                
      <li>
  
                          <a href="tools.html" title="Development Tools">
          <span class="none"></span>
        Development Tools</a>
            </li>
                
      <li>
  
                          <a href="contribution.html" title="Contribution">
          <span class="none"></span>
        Contribution</a>
            </li>
                
      <li>
  
                          <a href="related.html" title="Related Works">
          <span class="none"></span>
        Related Works</a>
            </li>
                
      <li>
  
                          <a href="blob/master/docs/prolobjectlink-jpi-jpl-yap.pdf" title="User Guide">
          <span class="none"></span>
        User Guide</a>
            </li>
                
      <li>
  
                          <a href="download.html" title="Download">
          <span class="none"></span>
        Download</a>
            </li>
                
      <li>
  
                          <a href="faq.html" title="FAQ">
          <span class="none"></span>
        FAQ</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                                                                                        
      <li>
  
                          <a href="project-info.html" title="Project Information">
          <span class="icon-chevron-right"></span>
        Project Information</a>
                  </li>
                                                                                                                                                                                                                                                                                                                                                                                    
      <li>
  
                          <a href="project-reports.html" title="Project Reports">
          <span class="icon-chevron-right"></span>
        Project Reports</a>
                  </li>
            </ul>
              
                            <form id="search-form" action="https://www.google.com/search" method="get" >
    
  <input value="https://prolobjectlink.github.io/prolobjectlink-jpi-jpl-yap" name="sitesearch" type="hidden"/>
  <input class="search-query" name="q" id="query" type="text" />
</form>
<script type="text/javascript" src="https://cse.google.com/brand?form=search-form"></script>
          
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <div class="section">
<h2><a name="Bidirectional_Interface"></a>Bidirectional Interface</h2>
<div class="section">
<h3><a name="Install"></a>Install</h3>
<p>Java Prolog Interface API is distributed with implementation adapter and concrete prolog driver library until it is possible according to related libraries licenses. The distributions are named normally such that prolobjectlink-jpi-jpl7-swi7-x.y.z-dist.zip meaning that this distribution is a JPI implementation over JPL version 7 or above and SWI-Prolog version 7 or above. The x.y.z is the distribution version. The distribution can be downloaded in zip or tar.gz compresses format. To install you need perform the following steps: &#x2022;Install Java Runtime Environment (JRE) 1.8 or above. &#x2022;Install Native Prolog Engine compatible to Operating System and your architecture. If the Prolog Engine to use is Java-based this step is omitted. &#x2022;Configure System Path with Prolog Engine routes. If the Prolog Engine to use is Java-based this step is omitted. &#x2022;Download Java Prolog Interface compatible to related prolog engine and unzip the distribution over Operating File System. &#x2022;Configure System Path with JPI unzip folder route. &#x2022;Open a new System console and type pllink &#x2013;i to see the product information. For the JPI beginners we recommended start with a Pure Java-Prolog Engine because have less configuration aspects and native engine are more difficult to link.</p></div>
<div class="section">
<h3><a name="Getting_started_Java_to_Prolog"></a>Getting started Java to Prolog</h3>
<p>After installation and architecture compression you can use the hello world sample for test the system integration. This hello world sample show how interacts with JPI from Java programming language with Abstracted Prolog Engine. For the first experience we suggesting use a Java-based Prolog engine like tuProlog because have less configuration aspects.</p>
<p>Create in your preferred development environment an empty project. Set in the project build path the JPI downloaded libraries located at lib folder. Create a Main Java class that look like below code:</p>
<div class="source"><pre class="prettyprint">       public class Main {
                public static void main(String[] args) {
                PrologProvider provider = Prolog.getProvider();
                PrologEngine engine = provider.newEngine();
                engine.asserta(&quot;sample('hello wolrd')&quot;);
                PrologQuery query=engine.query(&quot;sample(X)&quot;);
                System.out.println(query.one());
                }
        }
</pre></div></div>
<div class="section">
<h3><a name="Architecture"></a>Architecture</h3>
<p>JPI use a layered architecture pattern where every layer represents a component. The multi-engine Java Prolog connectors provide different levels of abstraction to simplify the implementations of common inter-operability task JPC. Java Prolog Connectors architectures describe three fundamentals layers, High-level API layer, Engine Adapter layer and Concrete Engine layer. High-level API layer define all services to be used by the users in the Java Prolog Application that is the final architecture layer on the architecture stack. High-level API provide the common implementation of Engine Abstraction, Data Type and Inter-Language conversion. The adapter layer adapts before mentioned features to communicate with the concrete Engine Layer, being the last responsible of execute the request services.</p>
<p>All existing Java Prolog Connectors implementation only bring support for Native Prolog Engines that have JVM bindings driver. JPI project is more inclusive and find connect all Prolog Engines Categories, Native and Java Based implementations. Some particular Java Based implementations in the future can be implement in strike forward mode the JPI interface. This particulars implementations reduce the impedance mismatch by remove the adapter layer. Therefore, JPI reference implementations will be faster than other that use adapter layer.</p>
<p>In JPI architecture stack in the bottom layer we have the Operating System. The Operating System can be Windows, Linux or Mac OS. Over Operating System, we have the native implementation of JVM and Prolog Engines like SWI, SWI7 and others. Over JVM and Prolog Engines we have Java Based Prolog Engines implementations and JVM bindings driver that share the runtime environment with JVM and native Prolog Engines. Over Java Based Prolog Engines implementations and JVM bindings drivers we have the JPI correspondent adapters. The adapters artifacts are the JPI implementations for each Prolog Engines. Over each adapter we have the JPI application provider interface and at the top stack we the final user application. The user application only interacts with the JPI providing single sourcing and transparency.</p></div>
<div class="section">
<h3><a name="Prolog_Provider"></a>Prolog Provider</h3>
<p>Prolog Provider is the mechanism to interact with all Prolog components. Provider classes implementations allow create Prolog Terms, Prolog Engine, Java Prolog Converter, Prolog Parsers and system logger. Using io.github.prolobjectlink.prolog.Prolog bootstrap class the Prolog Providers are created specifying the provider class in getProvider(Class<i>?</i>) method. This is the workflow start for JPI. When the Prolog Provider is created the next workflow step is the Prolog Terms creation using Java primitive types or using string with Prolog syntax. Provider allow create/parsing all Prolog Terms (Atoms, Numbers, Variables and Compounds). After term creation/parsing the next step is create an engine instance with newEngine() method. Using previous term creation and engine instance Prolog Queries can be formulated. This is possible because the engine class have multiples queries creation methods like a query factory. After query creation the Query interface present many methods to retrieve the query results. The result methods are based on result quantities, result terms, result object types, etc&#x2026; This is the final step in the workflow. In the table 10 is resumed all Prolog Provider Interface methods.</p></div>
<div class="section">
<h3><a name="Prolog_Terms"></a>Prolog Terms</h3>
<p>All Java Prolog connector libraries provide data type abstraction. Prolog data type abstraction have like ancestor the Term class. Prolog term is coding like abstract class and other Prolog terms are derived classes. In PrologTerm is defined the common term operation for all term hierarchy (functor, arity, compare, unify, arguments). The derived classes implement the correct behavior for each before mentioned operations. All Prolog data types PrologAtom, PrologNumber, PrologList, PrologStructure and PrologVariable are derived from this class. All before mentioned classes extends from this class the commons responsibilities. PrologTerm extends from Comparable interface to compare the current term with another term based on Standard Order.</p>
<p>PrologAtom represent the Prolog atom data type. Prolog atoms are can be of two kinds simple or complex. Simple atoms are defined like a single alpha numeric word that begin like initial lower case character. The complex atom is defining like any character sequence that begin and end with simple quotes. The string passed to build a simple atom should be match with {a-z}{A-Za-z0-9_}* regular expression. If the string passed to build an atom don't match with the before mentioned regular expression the atom constructor can be capable of create a complex atom automatically. For complex atom the string value can have the quotes or just can be absent. The printed string representation of the complex atom implementation set the quotes if they are needed. </p>
<div class="source"><pre class="prettyprint">    PrologTerm pam = provider.newAtom(&quot;pam&quot;);
         PrologTerm bob = provider.newAtom(&quot;bob&quot;);
</pre></div>
<p>PrologDouble represent a double precision floating point number. Extends from PrologNumber who contains an immutable Double instance. The Prolog Provider is the mechanism to create a new Prolog double invoking PrologProvider.newDouble(Number). PrologFloat represent a single precision floating point number. Extends from PrologNumber who contains an immutable Float instance. The Prolog Provider is the mechanism to create a new Prolog float invoking PrologProvider.newFloat(Number). PrologInteger represent an integer number. Extends from PrologNumber who contains an immutable Integer instance. The Prolog Provider is the mechanism to create a new Prolog integer invoking PrologProvider.newInteger(Number). Prolog term that represent a long integer number. Extends from PrologNumber who contains an immutable Long instance. The Prolog Provider is the mechanism to create a new Prolog long integer invoking PrologProvider.newLong(Number).</p>
<div class="source"><pre class="prettyprint">        PrologTerm pi = provider.newDouble(Math.PI);
        PrologTerm euler = provider.newFloat(Math.E);
        PrologTerm i = provider.newInteger(10);
        PrologTerm l = provider.newLong(10);
</pre></div>
<p>PrologVariable is created using PrologProvider.newVariable(int) for anonymous variables and PrologProvider.newVariable(String, int) for named variables. The Prolog variables can be used and reused because they remain in java heap. You can instantiate a prolog variable and used it any times in the same clause because refer to same variable every time. The integer parameter represents the declaration variable order in the Prolog clause starting with zero.</p>
<div class="source"><pre class="prettyprint">         PrologTerm x = provider.newVariable(&quot;X&quot;, 0);
         PrologTerm y = provider.newVariable(&quot;Y&quot;, 1);
         PrologTerm z = provider.newVariable(&quot;Z&quot;, 2);
         
         engine.assertz(
                provider.newStructure(grandparent, x, z),
                provider.newStructure(parent, x, y),
                        provider.newStructure(parent, y, z)
                        );
</pre></div>
<p>PrologReference term is inspired on JPL JRef. This term is like a structure compound term that have like argument the object identification atom. The functor is the @ character and the arity is 1. An example of this prolog term is e.g. @(J#00000000000000425). To access to the referenced object, is necessary use PrologTerm.getObject().</p>
<p>PrologList are a special compound term that have like functor a dot (.) and arity equals 2. Prolog list are recursively defined. The first item in the list is referred like list head and the second item list tail. The list tail can be another list that contains head and tail. A special list case is the empty list denoted by no items brackets ([]). The arity for this empty list is zero. The Prolog Provider is the mechanism to create a new PrologList is invoking PrologProvider.newList() for empty list or PrologProvider.newList(PrologTerm) for one item list or PrologProvider.newList(PrologTerm[]) for many items. </p>
<div class="source"><pre class="prettyprint">         PrologTerm empty = provider.newList();
         PrologTerm one = provider.newInteger(1);
         PrologTerm two = provider.newInteger(2);
         PrologTerm three = provider.newInteger(3);
         PrologTerm list = provider.newList(
                                new PrologTerm[] { one, two, three}
                        );              
         for (PrologTerm prologTerm : list) {
                System.out.println(prologTerm);
         }
</pre></div>
<p>PrologList implement Iterable interface to be used in for each sentence iterating over every element present in the list.</p>
<div class="source"><pre class="prettyprint">        Iterator&lt;PrologTerm&gt; i = list.iterator();
         while (i.hasNext()) {
                PrologTerm prologTerm = i.next();
                System.out.println(prologTerm);
         }
</pre></div>
<div class="source"><pre class="prettyprint">         for (Iterator&lt;PrologTerm&gt; i = list.iterator(); i.hasNext();) {
                PrologTerm prologTerm = i.next();
                System.out.println(prologTerm);
         }
</pre></div>
<p>Prolog structures consist in a relation the functor (structure name) and arguments enclosed between parenthesis. The Prolog Provider is the mechanism to create a new Prolog structures invoking PrologProvider.newStructure(String, PrologTerm...). Two structures are equals if and only if are structure and have equals functor and arguments. Structures terms unify only with same functor and arguments structures, with free variable or with with structures where your arguments unify if they have the same functor and arity. Structures have a special property named arity that means the number of arguments present in the structure. There are two special structures term. They are expressions (Two arguments structure term with operator functor) and atoms (functor with zero arguments). For the first special case must be used PrologProvider.newStructure(PrologTerm, String, PrologTerm) specifying operands like arguments and operator like functor.</p>
<div class="source"><pre class="prettyprint">        PrologTerm pam = provider.newAtom(&quot;pam&quot;);
        PrologTerm bob = provider.newAtom(&quot;bob&quot;);
        PrologTerm parent = provider.newStructure(&quot;parent&quot;, pam, bob);
</pre></div></div>
<div class="section">
<h3><a name="Prolog_Engine"></a>Prolog Engine</h3>
<p>Prolog Engine provide a general propose application interface to interact with Prolog Programing Language. Is a convenient abstraction for interacting with Prolog Virtual Machine from Java. In Java Prolog Engine connectors libraries, the abstract engine is able to answer queries using the abstract term representation before mentioned. There are several implementation engines and in this project we try connect from top level engine to more concrete or specific Prolog Engine. Based on JPC we have a top level engine that communicate with more concretes engines. Over this concretes engines we offer several services to interact with the concrete engines with low coupling and platform independency.</p></div>
<div class="section">
<h3><a name="Prolog_Query"></a>Prolog Query</h3>
<p>Prolog query is the mechanism to query the prolog database loaded in prolog engine. The way to create a new prolog query is invoking query() method in the Prolog Engine. When this method is called the prolog query is open an only dispose() in PrologQuery object close the current query and release all internal resources. Prolog query have several methods to manipulate the result objects. The main difference is in return types and result quantities. The result types enough depending of desire data type. Maps of variables name key and Prolog terms as value, Maps of variables name key and Java objects as value, List of before mentioned maps, Prolog terms array, Prolog terms matrix, list of Java Objects and list of list of Java Objects. Respect to result quantities Prolog query offer one, n-th or all possible solutions. This is an important feature because the Prolog engine is forced to retrieve the necessary solution quantities. Prolog query implement Iterable and Iterator. This implementation helps to obtain successive solutions present in the query.</p>
<div class="source"><pre class="prettyprint">        public class Main {
        public static void main(String[] args) {
                PrologProvider provider = Prolog.getProvider();
                PrologEngine engine = provider.newEngine(&quot;zoo.pl&quot;);
                 PrologVariable x = provider.newVariable(&quot;X&quot;, 0);
                 PrologQuery query =                    engine.query(provider.newStructure(&quot;dark&quot;, x));
                 while (query.hasNext()) {
                        PrologTerm value =                                      query.nextVariablesSolution().get(&quot;X&quot;);
                        System.out.println(value);
                 }
                 query.dispose();
                 engine.dispose();
                }
        }
</pre></div>
<div class="source"><pre class="prettyprint">        public class Main {
                public static void main(String[] args) {
                        PrologProvider provider = Prolog.getProvider();
                         PrologEngine engine = provider.newEngine(&quot;zoo.pl&quot;);
                         PrologVariable x = provider.newVariable(&quot;X&quot;, 0);
                         PrologQuery query =                            engine.query(provider.newStructure(&quot;dark&quot;, x));
                         for (Collection&lt;PrologTerm&gt; col : query) {
                                for (PrologTerm prologTerm : col) {
                                        System.out.println(prologTerm);
                                }
                         }
                         query.dispose();
                         engine.dispose();
                }
        }
</pre></div></div>
<div class="section">
<h3><a name="Prolog_Query_Builder"></a>Prolog Query Builder</h3>
<p>Prolog query builder to create prolog queries. The mechanism to create a new query builder is using PrologEngine.newQueryBuilder(). The query builder emulates the query creation process. After define all participant terms with the begin(PrologTerm) method, we specify the first term in the query. If the query has more terms, they are created using comma(PrologTerm) for everyone. Clause builder have a getQueryString() for string representation of the clause in progress. After clause definition this builder have query() method that create the final query instance ready to be used. The follow code show how create a Prolog query ?- big(X), dark(X). using PrologQueryBuilder interface.</p>
<div class="source"><pre class="prettyprint">        PrologVariable x = provider.newVariable(&quot;X&quot;, 0);
        PrologStructure big = provider.newStructure(&quot;big&quot;, x);
        PrologStructure dark = provider.newStructure(&quot;dark&quot;, x);
        PrologQueryBuilder builder = engine.newQueryBuilder();
        PrologQuery query = builder.begin(dark).comma(big).query();
</pre></div></div>
<div class="section">
<h3><a name="Prolog_Clause"></a>Prolog Clause</h3>
<p>Prolog clause is composed by two prolog terms that define a prolog clause, the head and the body. This representation considers the prolog clause body like a single term. If the body is a conjunctive set of terms, the body is a structure with functor/arity (, /2) and the first argument is the first element in the conjunction and the rest is a recursive functor/arity (, /2). The functor and arity for the clause is given from head term functor and arity. This class define some properties for commons prolog clause implementations. They are boolean flags that indicate if the prolog clause is dynamic multi-file and discontiguos. This class have several methods to access to the clause components and retrieve some clause properties and information about it. Additionally, this class contains a prolog provider reference for build terms in some operations.</p></div>
<div class="section">
<h3><a name="Prolog_Clause_Builder"></a>Prolog Clause Builder</h3>
<p>Prolog clause builder to create prolog clauses. The mechanism to create a new clause builder is using PrologEngine.newClauseBuilder(). The clause builder emulates the clause creation process. After define all participant terms with the begin(PrologTerm) method, we specify the head of the clause. If the clause is a rule, after head definition, the clause body is created with neck(PrologTerm) for the first term in the clause body. If the clause body have more terms, they are created using comma(PrologTerm) for everyone. Clause builder have a getClauseString() for string representation of the clause in progress. After clause definition this builder have asserta(), assertz(),clause(),retract() that use the wrapped engine invoking the correspondent methods for check, insert or remove clause respectively.</p>
<div class="source"><pre class="prettyprint">        PrologTerm z = provider.newVariable(&quot;Z&quot;, 0);
        PrologTerm darkZ = provider.newStructure(&quot;dark&quot;, z);
        PrologTerm blackZ = provider.newStructure(&quot;black&quot;, z);
        PrologTerm brownZ = provider.newStructure(&quot;brown&quot;, z);
        PrologClauseBuilder builder = engine.newClauseBuilder();
        builder.begin(darkZ).neck(blackZ).assertz();
        builder.begin(darkZ).neck(brownZ).assertz();
</pre></div>
<p>The Prolog result in database is showed in the follow code. The table 19 show the Prolog clause builder interface methods.</p>
<div class="source"><pre class="prettyprint">        dark(Z): - 
                black(Z).
         dark(Z): - 
                brown(Z).
</pre></div></div>
<div class="section">
<h3><a name="Prolog_Scripting_in_Java"></a>Prolog Scripting in Java</h3>
<p>Java 6 added scripting support to the Java platform that lets a Java application execute scripts written in scripting languages such as Rhino JavaScript, Groovy, Jython, JRuby, Nashorn JavaScript, etc. All classes and interfaces in the Java Scripting API are in the javax.script package. Using a scripting language in a Java application provides several advantages, dynamic type, simple way to write programs, user customization, easy way to develop and provide domain-specific features that are not available in Java. For achieve this propose Java Scripting API introduce a scripting engine component. A script engine is a software component that executes programs written in a particular scripting language. Typically, but not necessarily, a script engine is an implementation of an interpreter for a scripting language. To run a script in Java is necessary perform the following three steps, create a script engine manager, get an instance of a script engine from the script engine manager and Call the eval() method of the script engine to execute a script.</p>
<div class="source"><pre class="prettyprint">        public class Main {
                public static void main(String[] args) {
                        ScriptEngineManager manager = new ScriptEngineManager();
                        ScriptEngine engine = manager.getEngineByName(&quot;prolog&quot;);
                        Boolean result = engine.eval(&quot;?- X is 5+3.&quot;);
                        Integer solution = engine.get(&quot;X&quot;);
                        System.out.println(solution);
                }
        }
</pre></div>
<p>Using script engine, it possible read Prolog source file. Read Prolog source file allow coding all prolog source in separate mode respect to Java program.</p>
<div class="source"><pre class="prettyprint">        public class Main {
                public static void main(String[] args) {
                        ScriptEngineManager manager = new ScriptEngineManager();
                        ScriptEngine engine = manager.getEngineByName(&quot;prolog&quot;);
                        Boolean read = engine.eval(new FileReader(&quot;family.pl&quot;));
                        Boolean eval = engine.eval(&quot;?- parent( Parent, Child)&quot;);
                        Object parent = engine.get(&quot;Parent&quot;);
                        Object child = engine.get(&quot;Child&quot;);
                        System.out.println(parent);
                        System.out.println(child);
                }
        }
</pre></div></div>
<div class="section">
<h3><a name="Getting_started_Prolog_to_Java"></a>Getting started Prolog to Java</h3>
<p>This is an overview of an interface which allows SWI-Prolog programs to dynamically create and manipulate Java objects.</p>
<div class="section">
<h4><a name="JPL_types_Java_types_as_seen_by_Prolog"></a>JPL types (Java types, as seen by Prolog)</h4>
<p>All Java values and object references which are passed between Prolog engines and Java VMs via JPL's Prolog API are seen as instances of types within this simplified JPL type system:</p>
<p>a datum (this term is introduced, out of necessity, to refer jointly to values and refs)</p>
<p>is a value (values are copied between Prolog and the JVM)</p>
<p>is a boolean</p>
<p>or a char</p>
<p>or a long, int, short or byte</p>
<p>or a double or float</p>
<p>or a string (an instance of java.lang.String)</p>
<p>or a void (an artificial value returned by calls to Java void methods)</p>
<p>or a ref</p>
<p>is null</p>
<p>or an object (held within the JVM, and represented in Prolog by a canonical reference)</p>
<p>is an array</p>
<p>or a class instance (other than of java.lang.String)</p></div>
<div class="section">
<h4><a name="Representation_of_Java_values_and_references_within_Prolog"></a>Representation of Java values and references within Prolog</h4>
<p>Instances of JPL types are represented within Prolog as follows:</p>
<p>boolean has two values, represented by @(true) and @(false)</p>
<p>char values are represented by corresponding Prolog integers</p>
<p>int, short and byte values are represented by corresponding Prolog integers</p>
<p>long values are represented as Prolog integers if possible (32-bit in current SWI-Prolog), else as jlong(Hi,Lo) where Hi is an integer corresponding to the top32 bits of the long, and Lo similarly represents the lower 32 bits</p>
<p>double and float values are represented as Prolog floats (which are equivalent to Java doubles) (there may be minor rounding, normalisation or loss-of-precision issues when a Java float is widened to a Prolog float then narrowed back again, but what the heck)</p>
<p>string values (immutable instances of java.lang.String) are represented as Prolog atoms (in UTF-8 encoding)</p>
<p>null has only one value, represented as @(null)</p>
<p>void has only one value, represented as @(void)</p>
<p>array and class instance references are currently represented as @(Tag), where Tag ia an atom whose name encodes a JNI global reference value; this may change, but won't affect Prolog programs which respect the opacity of references</p></div>
<div class="section">
<h4><a name="Representation_of_Java_types_within_Prolog_1:_structured_notation"></a>Representation of Java types within Prolog (1): structured notation</h4>
<p>The JPL Prolog API allows Prolog applications to inspect, manipulate, and reason about the types of Java values, references, methods etc., and this section describes how these types themselves (as opposed to instances thereof) are represented. Predicates which pass these type representations include jpl_class_to_type/2, jpl_classname_to_type/2, jpl_datum_to_type/2, jpl_is_object_type/1, jpl_is_type/1, jpl_object_to_type/2, jpl_primitive_type/1, jpl_ref_to_type/2, jpl_type_to_class/2. jpl_type_to_classname/2.</p>
<p>void is represented as void</p>
<p>null is represented as null</p>
<p>the primitive types are represented as boolean, char, byte, short, int, long, float, double</p>
<p>classes are represented as class(package_parts,classname_parts)</p>
<p>e.g. class([java,util],['Date'])</p>
<p>array types are represented as array(type)</p>
<p>e.g. array(boolean)</p>
<p>e.g. array(class([java,lang],['String'])</p>
<p>This structured notation for Java types is designed to be convenient for composition and decomposition by matching (unification).</p></div>
<div class="section">
<h4><a name="Predicates"></a>Predicates</h4>
<div class="section">
<h5><a name="Creating_instances_of_Java_classes"></a>Creating instances of Java classes</h5>
<p>To create an instance of a Java class from within Prolog, call jpl_new(+Class,+Params,-Ref) with a classname, a list of actual parameters for the constructor, and a variable to be bound to the new reference, e.g.</p>
<div class="source"><pre class="prettyprint">    jpl_new( 'javax.swing.JFrame', ['frame with dialog'], F)
</pre></div>
<p>which binds F to a new object reference, e.g.</p>
<div class="source"><pre class="prettyprint">     @('J#0008272420')
</pre></div>
<p>(not that the details of this structure are of any necessary concern to the Prolog programmer or to the applications she writes). NB for convenience, this predicate is overloaded: Class can also be a class type in structured notation, e.g. array(boolean).</p></div>
<div class="section">
<h5><a name="Calling_methods_of_Java_objects_or_classes"></a>Calling methods of Java objects or classes</h5>
<p>The object reference generated by the jpl_new/3 call (above) can be passed to other JPL API predicates such as</p>
<div class="source"><pre class="prettyprint">    jpl_call( +Ref, +Method, +Params, -Result)
</pre></div>
<p>e.g.</p>
<div class="source"><pre class="prettyprint">    jpl_call( F, setVisible, [@(true)], _)
</pre></div>
<p>which calls the setVisible method of the object to which F refers, effectively passing it the Java value true.</p>
<p>(This call should display the new JFrame in the top left corner of the desktop.)</p>
<p>Note the anonymous variable passed as the fourth argument to jsp_call/4. A variable in this position receives the result of the method call: either a value or a reference. Since SetVisible() is a void method, the call returns the (artificial) reference @(void).</p>
<p>Some may prefer to code this call thus:</p>
<div class="source"><pre class="prettyprint">    jpl_call( F, setVisible, [@true], @void)
</pre></div>
<p>which documents the programmer's understanding that this is a void method (and fails if it isn't :-).</p>
<p>If the +Ref argument represents a class, then the named static method of that class is called.</p></div>
<div class="section">
<h5><a name="Fetching_field_values_of_Java_objects_or_classes"></a>Fetching field values of Java objects or classes</h5>
<p>The jpl_get/3 API predicate can retrieve the value of an instance field or a static field, e.g.</p>
<div class="source"><pre class="prettyprint">    jpl_get( 'java.awt.Color', pink, Pink)
</pre></div>
<p>which binds the Prolog variable Pink to a reference to the predefined java.awt.Color &quot;constant&quot; which is held in the static final .pink field of the java.awt.Color class.</p>
<p>More generally, jpl_get/3 has the following interface:</p>
<div class="source"><pre class="prettyprint">    jpl_get( +Class_or_Object, +Field, -Datum)
</pre></div>
<p>If the first argument represents a class, then a static field of that class with FieldName is accessed.</p></div>
<div class="section">
<h5><a name="Setting_field_values_of_Java_objects_or_classes"></a>Setting field values of Java objects or classes</h5>
<p>Object and class fields can be set (i.e. have values or references assigned to them) by the jpl_set/3 API procedure, which has the following interface:</p>
<div class="source"><pre class="prettyprint">    jpl_set( +Class_or_Object, +Field, +Datum)
</pre></div>
<p>where Datum must be a value or reference of a type suitable for assignment to the named field of the class or object.</p></div>
<div class="section">
<h5><a name="A_slightly_longer_example"></a>A slightly longer example</h5>
<p>This code fragment</p>
<div class="source"><pre class="prettyprint">    findall(
        Ar,
        (   current_prolog_flag( N, V),
            term_to_atom( V, Va),
            jpl_new( '[Ljava.lang.String;', [N,Va], Ar)
        ),
        Ars
    ),
    jpl_new( '[[Ljava.lang.String;', Ars, Ac),
    jpl_datums_to_array( [name,value], Ah),
    jpl_new( 'javax.swing.JFrame', ['current_prolog_flag'], F),
    jpl_call( F, getContentPane, [], CP),
    jpl_new( 'javax.swing.JTable', [Ac,Ah], T),
    jpl_new( 'javax.swing.JScrollPane', [T], SP),
    jpl_call( CP, add, [SP,'Center'], _),
    jpl_call( F, setSize, [600,400], _),
</pre></div>
<p>builds an array of arrays of strings containing the names and values of the current SWI-Prolog &quot;flags&quot;, and displays it in a JTable within a ScrollPane within a JFrame:</p>
<p>In addition to JPL API calls, this code calls jpl_datums_to_array/2, a utility which converts any list of valid representations of Java values (or objects) into a new Java array, whose base type is the most specialised type of which all list members are instances, and which is defined thus:</p>
<div class="source"><pre class="prettyprint">    jpl_datums_to_array( Ds, A) :-
        ground( Ds),
        jpl_datums_to_most_specific_common_ancestor_type( Ds, T),
        jpl_new( array(T), Ds, A).
</pre></div>
<p>Having found the &quot;most specific common ancestor type&quot; (my phrase :-), a new array of this type is created, whose elements are initialised to the successive members of the list of datums.</p>
<p>This illustrates another mode of operation of jpl_new/3:</p>
<div class="source"><pre class="prettyprint">    jpl_new( +ArrayType, +InitialValues, -ArrayRef)
</pre></div>
<p>Don't forget the possibility of writing and manipulating new Java classes to serve your Prolog applications: this interface is not designed to make Java programming redundant :-)</p>
<div class="source"><pre class="prettyprint"> jpl_new( +X, +Argz, -V) :-
</pre></div>
<p>X can be:</p>
<p>a suitable type i.e. any class(_,_), array(_) or primitive type (e.g. byte but not void) an atomic classname e.g. 'java.lang.String' e.g. 'Ljava.lang.String;' (a redundant but legitimate form) an atomic descriptor e.g. '[I' a class object i.e. an object whose type is class([java,lang],['Class'])</p>
<p>if X denotes a primitive type and Argz is castable to a value of that type, then V is that value (a pointless mode of operation, but somehow complete...)</p>
<p>if X denotes an array type and Argz is a non-negative integer, then V is a new array of that many elements, initialised to the appropriate default value</p>
<p>if X denotes an array type and Argz is a list of datums, each of which is (independently) castable to the array element type, then V is a new array of as many elements as Argz has members, initialised to the results of casting the respective members of Argz</p>
<p>if X denotes a non-array object type and Argz is a list of datums, then V is the result of an invocation of that type's most specifically-typed constructor to whose respective parameters the members of Argz are assignable</p>
<div class="source"><pre class="prettyprint"> jpl_call( +X, +Method, +Args, -R) :-
</pre></div>
<p>X can be:</p>
<p>a type, class object or classname (for static methods of the denoted class, or for static or instance methods of java.lang.Class)</p>
<p>a class instance or array (for static or instance methods)</p>
<p>Method can be:</p>
<p>an atomic method name (if this name is ambiguous, as a result of method overloading, then it will be resolved by considering the types of Args, as far as they can be inferred)</p>
<p>an integral method index (untested: for static overload resolution)</p>
<p>a methodID/1 structure (ditto)</p>
<p>Args must be</p>
<p>a proper list (possibly empty) of ground arguments</p>
<p>Finally, an attempt will be made to unify R with the returned result.</p>
<div class="source"><pre class="prettyprint"> jpl_set( +X, +Field, +V) :-
</pre></div>
<p>basically, sets the Fspec-th field of object X to value V</p>
<p>X can be:</p>
<p>a class object, a classname, or an (object or array) type (for static fields, or java.lang.Class fields)</p>
<p>a class instance (for non-static fields)</p>
<p>an array (for indexed element or subrange assignment)</p>
<p>but not a string (no fields to retrieve)</p>
<p>Field can be:</p>
<p>an atomic field name (overloading will be resolved dynamically, by considering the inferred type of V)</p>
<p>an integral field index (static resolution: not tried yet)</p>
<p>a fieldID/1 (static resolution: not tried yet)</p>
<p>a variable (field names, or array indices, are generated)(?!)</p>
<p>an array index I (X must be an array object: X[I] is assigned V)</p>
<p>a pair I-J of integers (J can be a variable) (X must be an array object, V must be a list of values: X[I-J] will be assigned V)</p>
<p>V must be ground (although one day we may pass variables to JPL?!)</p>
<div class="source"><pre class="prettyprint"> jpl_get( +X, +Field, -V) :-
</pre></div>
<p>X can be:</p>
<p>a class object, a classname, or an (object or array) type (for static fields, or java.lang.Class fields)</p>
<p>a class instance (for non-static fields)</p>
<p>an array (for the 'length' pseudo field, or for indexed element retrieval)</p>
<p>but not a String (clashes with classname; anyway, java.lang.String has no fields to retrieve)</p>
<p>Field can be</p>
<p>an atomic field name</p>
<p>or an integral field index (these are a secret :-)</p>
<p>or a fieldID/1 (not for general consumption :-)</p>
<p>or an integral array index (high-bound checking is done by JVM, maybe throwing an exception)</p>
<p>or a variable (field names, or array indices, are generated)</p>
<p>or a pair I-J of integers or variables (array subranges are generated) (relational or what?!)</p>
<p>Immediately before jpl_get/4 returns, an attempt will be made to unify V with the internally computed result.</p></div>
<div class="section">
<h5><a name="Exceptions_thrown_by_Java"></a>Exceptions thrown by Java</h5>
<p>Uncaught exceptions thrown by the JVM in the course of handling a JPL 3.x Prolog API call are mapped onto Standard Prolog exceptions, e.g.</p>
<div class="source"><pre class="prettyprint">    jpl_new( 'java.util.Date', [yesterday], D)
</pre></div></div>
<div class="section">
<h5><a name="Raises_the_Prolog_exception"></a>Raises the Prolog exception</h5>
<div class="source"><pre class="prettyprint">    java_exception('java.lang.IllegalArgumentException', @'J#0008408972')
</pre></div>
<p>because, as the exception suggests, yesterday is not a valid constructor argument.</p>
<p>Java exceptions are always returned as Prolog exceptions with this structure:</p>
<div class="source"><pre class="prettyprint">    java_exception( classname, reference_to_exception_object)
</pre></div></div></div></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                    2020&#x2013;2022
                        <a href="https://prolobjectlink.github.io/prolobjectlink-jpi-jpl-yap">Prolobjectlink Project</a>.
            All rights reserved.    
      </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
